- [12. Redis缓存穿透和雪崩（高频面试/必考）](#12-redis缓存穿透和雪崩高频面试必考)
  - [缓存穿透（查不到）](#缓存穿透查不到)
  - [缓存击穿（查的线程量太大）](#缓存击穿查的线程量太大)
  - [缓存雪崩（缓存大面积失效）](#缓存雪崩缓存大面积失效)
- [13. 为什么Redis单线程还那么快？](#13-为什么redis单线程还那么快)
- [14. Redis为什么快？](#14-redis为什么快)
- [场景题:sunrise_over_mountains:](#场景题sunrise_over_mountains)
    - [分布式锁🔒](#分布式锁)
    - [缓存+数据库双写一致性💽](#缓存数据库双写一致性)
    - [延迟双删❌](#延迟双删)





## 12. Redis缓存穿透和雪崩（高频面试/必考）

> 服务的高可用问题！



### 缓存穿透（查不到）

**定义：**请求的数据，Redis中和数据库中都没有，从而让过多请求落在数据库上，造成数据库崩掉。

**场景**：一般在高并发访问某一个共同资源的场景：如秒杀活动；

**解决方案：**

1. 布隆过滤器

布隆过滤器是一种数据结构，**对可以能查询的参数以hash的形式进行存储**，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力。

2. 缓存空对象

存在两个问题：

1. 需要更多的空间去存储没有意义的空值
2. 设置了过期时间，还是会存在**缓存层和存储层的数据在一段时间内不一致的情况**，对于需要保持一致性的业务会有影响。

![image-20220226154601859](redis_%E9%9D%A2%E8%AF%95.assets/image-20220226154601859.png)



### 缓存击穿（查的线程量太大）

**定义**：在key过期后，到重新缓存key上来的这一个小区间内，访问量巨大直接击穿缓存层，让存储层崩掉。

**场景**：微博热搜

**解决方案**：

1. 设置热点数据永远不过期
2. 加互斥锁

### 缓存雪崩（缓存大面积失效）

**定义**：某一时间段，缓存集体过期失效

**场景**：Redis宕机！双12 访问商品 1h expire

**解决方案**：

1. redis高可用：集群。异地多活！
2. 数据预热：提前缓存好热点数据
3. 随机过期时间
4. 限流降级：互斥锁，只允许一个线程来查询数据和写缓存，其他的等待。



## 13. 为什么Redis单线程还那么快？

redis会基于这些建立的连接去探测哪个连接**已经接收完了客户端的请求数据**（注意：不是探测哪个连接建立好了，而是探测哪个接收完了请求数据），而且这里的探测动作就是单线程的开始，**一旦探测到**则基于接收到的数据**开始数据处理阶段**，然后返回数据，再继续探测下一个已经接收完请求数据的网络连接。注意，从探测到数据处理再到数据返回，全程单线程。这应该就是所谓的redis单线程



## 14. Redis为什么快？

- 因为Redis是基于内存的、采用单进程单线程模型的KV数据库。**避免了线程切换和锁带来的性能消耗**。官方提供的数据：QPS 11W次/s, 写的速度是81000次/s 。

- 和HashMap一样，查找和操作的时间复杂度O(1)
- 多路I/O复用模型，非阻塞IO，可以处理大量的客户端请求，实现高吞吐量。
- Redis的瓶颈最有可能是机器内存的大小或者网络带宽，而不是CPU





## 场景题:sunrise_over_mountains:

#### 分布式锁🔒

在Redis存一个代表锁的字符串

**加锁：`set key value nx ex seconds`将加锁和过期命令编排到一起，实现原子操作，避免死锁。**

**解锁：**`del key`



**问题：**当在并发下，进程A还没执行完，锁到期释放了。然后等进程A结束任务，准备执行释放锁操作时，进程B的锁被进程A释放。

<img src="redis_%E9%9D%A2%E8%AF%95.assets/image-20220328100629009.png" alt="image-20220328100629009" style="zoom:50%;" />

**解决办法：**

1. 加锁时，给锁加标识，每个进程记住自己的标识。释放之前先判断是自己的锁才释放。比如：给个随机值
2. 解锁时，先判断，再释放，且保证2步是原子性操作。采用Lua脚本



#### 缓存+数据库双写一致性💽

**最终目的：**缓存和数据库的数据一致且都是新数据

**考虑方案：1. 先缓存后数据库；2.先数据库后缓存；**

- 先删除**缓存**，再更新**数据库**；

  - **会出现问题的情况**：

  <img src="redis_%E9%9D%A2%E8%AF%95.assets/image-20220328104836854.png" alt="image-20220328104836854" style="zoom:20%;" /> 

  1. 进程A**删除缓存**成功；
  2. 进程A**更新数据库**失败；
  3. 进程B从**缓存读不到**数据；
  4. 进程B去**数据库读取旧数据**，并**更新到缓存**；

  **结果：旧数据一致**

  - **不会出现问题的情况：**

    <img src="redis_%E9%9D%A2%E8%AF%95.assets/image-20220328105233486.png" alt="image-20220328105233486" style="zoom:20%;" /> 

- 1. 进程A**删除缓存成功**；
  2. 进程B**读取缓存失败**；
  3. 进程B**读取数据库成功**，得到旧数据；
  4. 进程B将旧的数据成功更新到缓存；
  5. 进程A**将新数据更新到数据库**；

  **结果：数据不一致。缓存是旧数据，数据库是新数据。**

----

- 先更新**数据库**，再删除**缓存**；

  - **会出现问题的情况：**

  <img src="redis_%E9%9D%A2%E8%AF%95.assets/image-20220328104921473.png" alt="image-20220328104921473" style="zoom:20%;" /> 

  1. 进程A**更新数据库**成功；
  2. 进程A**删除缓存**失败；
  3. 进程B**读取缓存**成功；

  **结果：数据不一致，读取的是旧数据**

  - **没有问题的情况：**

    <img src="redis_%E9%9D%A2%E8%AF%95.assets/image-20220328105644140.png" alt="image-20220328105644140" style="zoom:20%;" /> 

  1. 进程A**更新数据库**成功；
  2. 进程B**读取缓存**成功，读取到旧数据；
  3. 进程A**删除缓存**成功；

  **结果：缓存和数据库的数据一致且都是最新数据。**除了**在删除缓存前**的一些线程会**读取到旧的缓存**记录，**其他的都是新的**。



**<u>那这两种失败情况如何解决呢？</u>**

- **重试机制**：<img src="redis_%E9%9D%A2%E8%AF%95.assets/image-20220328104944026.png" alt="image-20220328104944026" style="zoom:20%;" />
  1. **更新数据库**成功；
  2. **删除缓存**失败；
  3. 将数据**加入到消息队列**
  4. 业务代码**消费消息队列**
  5. 根据消息内容，**发起重试机制**，**从缓存中删除这条记录**；



**结论，采用先更新数据库，再删除缓存的策略，影响最小！期间出现错误，采用重试机制解决。**



#### 延迟双删❌

如果我们真的**需要使用先缓存后数据库的方案**，采用***延时双删*** 来避免数据不一致的问题。

1. 线程A**删除缓存**成功；
2. 线程B**读取数据库旧数据并更新到缓存**
3. 线程A**更新数据库**；
4. 线程A **sleep**一会；
5. 线程A**删除缓存**；

**<u>读写分离架构怎么办？</u>**

<img src="redis_%E9%9D%A2%E8%AF%95.assets/image-20220328111422644.png" alt="image-20220328111422644" style="zoom:20%;" /> 

sleep的时间长一点，要考虑sync的时间，然后等到从库也同步了新的数据后，在进行删除缓存操作。
> 为了突击面试，短时间内整理的重点
- [1. 绪论](#1-绪论)
  - [OS的目的和作用](#os的目的和作用)
  - [OS的基本特征](#os的基本特征)
  - [OS主要功能](#os主要功能)
  - [OS结构](#os结构)
    - [内核](#内核)
    - [外壳](#外壳)
    - [系统调用](#系统调用)
    - [宏内核和微内核](#宏内核和微内核)
      - [!image-20220130142122703](#image-20220130142122703usersyetaolibraryapplication-supporttypora-user-imagesimage-20220130142122703png)
- [2. 进程和线程](#2-进程和线程)
  - [进程](#进程)
    - [进程状态](#进程状态)
    - [进程调度算法🌟](#进程调度算法)
      - [1. 批处理系统](#1-批处理系统)
      - [2. 交互式系统](#2-交互式系统)
      - [3. 实时系统](#3-实时系统)
    - [进程同步🌟](#进程同步)
      - [基本概述](#基本概述)
    - [进程通信](#进程通信)
      - [1、管道( pipe )](#1管道-pipe-)
      - [2、有名管道（FIFO）](#2有名管道fifo)
      - [3、信号](#3信号)
      - [4、信号量](#4信号量)
      - [5、消息队列](#5消息队列)
      - [6、共享内存](#6共享内存)
      - [7、套接字socket](#7套接字socket)
  - [线程](#线程)
    - [线程状态](#线程状态)
    - [线程同步🌟](#线程同步)
    - [线程通信](#线程通信)
      - [1. 共享内存](#1-共享内存)
      - [2. 消息传递](#2-消息传递)
      - [3. 管道流](#3-管道流)
  - [区别](#区别)
- [3. 处理机（CPU）调度与死锁](#3-处理机cpu调度与死锁)
  - [处理机调度层次](#处理机调度层次)
  - [调度算法的目标](#调度算法的目标)
    - [批处理系统目标](#批处理系统目标)
    - [分时系统目标](#分时系统目标)
    - [实时系统目标](#实时系统目标)
  - [调度队列模型](#调度队列模型)
  - [调度队列准则](#调度队列准则)
  - [调度算法](#调度算法)
    - [作业调度和进程调度的区别](#作业调度和进程调度的区别)
- [4. 存储器管理](#4-存储器管理)
  - [存储器概述](#存储器概述)
    - [层次结构](#层次结构)
    - [管理的功能](#管理的功能)
    - [为什么需要虚拟地址？](#为什么需要虚拟地址)
  - [内存管理机制🌟](#内存管理机制)
    - [块式管理](#块式管理)
    - [页式管理](#页式管理)
      - [快表(解决：快)](#快表解决快)
      - [多级页表(解决：大)](#多级页表解决大)
    - [段式管理](#段式管理)
    - [段页式管理](#段页式管理)
    - [分页机制和分段机制的共同点和区别](#分页机制和分段机制的共同点和区别)
  - [虚拟存储器](#虚拟存储器)
    - [**请求分页存储管理**](#请求分页存储管理)
      - [请求分页的页表机制](#请求分页的页表机制)
      - [缺页中断机构](#缺页中断机构)
      - [地址变换机构🌟](#地址变换机构)
      - [请求分页系统的内存分配](#请求分页系统的内存分配)
      - [页面调入策略](#页面调入策略)
      - [页面置换算法🌟](#页面置换算法)
    - [**请求分段存储管理**](#请求分段存储管理)
    - [**请求段页式存储管理**](#请求段页式存储管理)
    - [局部性原理](#局部性原理)
    - [CPU寻址](#cpu寻址)
    - [抖动](#抖动)
# 1. 绪论

## OS的目的和作用

1. 用户和计算机硬件的接口
2. 计算机四类资源的管理者
3. 实现了对计算机资源的抽象

![image-20220130131658360](/Users/yetao/Library/Application Support/typora-user-images/image-20220130131658360.png)

## OS的基本特征

1. 共享：操作系统程序和多个用户程序共享计算机资源
2. 并发：在同一时间间隔内，多个事件发生
3. 异步：由于资源、IO因素，通常进程执行不可能“一气呵成”，需要去异步等待资源或I/O
4. 虚拟：定义是把一个物理上的实体变为逻辑上的多个对应物。例如：一块硬盘被虚拟成多个虚拟硬盘（C盘/D盘……）；一个CPU被虚拟成多个逻辑上CPU，也被称作虚拟处理器。

## OS主要功能

1. **管理处理器**（CPU中央处理器 Central Processing Unit中央处理单元）
   - 进程控制
   - 进程同步
   - 进程通信
   - 进程调度
2. **管理存储器**（内存）
   - 内存分配
   - 内存保护
   - 地址映射
   - 内存扩充
3. **管理文件**（硬盘）
   - 文件存储空间
   - 目录管理
   - 文件读写
4. **管理设备（I/O）**
   - 设备缓冲
   - 设备分配
   - 设备处理

## OS结构

内核Kernel AND 外壳Shell，区分机器的两种运行状态是为了给操作系统内核某些特权，使其仅当在核心态下才能执行特权指令。

### 内核

> 实现操作系统基本功能的程序模块的集合，在核心态下运行

### 外壳

> 运行在内核之上的、完成OS外层功能（e.g. 命令解释、机器诊断等）的程序，在用户态运行

### 系统调用

> 当一个进程在用户态需要使用到内核态的功能的时候，就**陷入系统调用**从而进入内核，由操作系统内核代为完成。

**Linux 的系统调用主要有以下这些：**

| Task     | Commands                    |
| -------- | --------------------------- |
| 进程控制 | fork(); exit(); wait();     |
| 进程通信 | pipe(); shmget(); mmap();   |
| 文件操作 | open(); read(); write();    |
| 设备操作 | ioctl(); read(); write();   |
| 信息维护 | getpid(); alarm(); sleep(); |
| 安全     | chmod(); umask(); chown();  |

![image-20220130135515974](/Users/yetao/Library/Application Support/typora-user-images/image-20220130135515974.png)



### 宏内核和微内核

> 内核的进一步划分

![image-20220130142050846](/Users/yetao/Library/Application Support/typora-user-images/image-20220130142050846.png)

#### ![image-20220130142122703](/Users/yetao/Library/Application Support/typora-user-images/image-20220130142122703.png)



# 2. 进程和线程

## 进程

> **资源分配的基本单位**
>
> 进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

### 进程状态

1. 创建
2. 就绪
3. 运行
4. 阻塞
5. 结束/停止

### 进程调度算法🌟

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

#### 1. 批处理系统

批处理系统没有太多的用户操作，在该系统中，调度算法目标是**保证吞吐量和周转时间**（从提交到终止的时间）。

**1.1 先来先服务 first-come first-serverd（FCFS）**

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为**短作业必须一直等待前面的长作业**执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

**1.2 短作业优先 shortest job first（SJF）**

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

**长作业有可能会饿死**，处于一直等待短作业执行完毕的状态。因为如果**一直有短作业到来，那么长作业永远得不到调度**。

**1.3 最短剩余时间优先 shortest remaining time next（SRTN）**

最短作业优先的抢占式版本，**按剩余运行时间的顺序**进行调度。 **当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。**如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

#### 2. 交互式系统

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是**快速地进行响应**。

**2.1 时间片轮转**

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。**当时间片用完**时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它**送往就绪队列的末尾**，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，**如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。**
- 而如果时间片过长，那么**实时性**就不能得到保证。

[![img](https://camo.githubusercontent.com/a87daa8201015ff54a213d9ea95c1e49e7eec447938c441dd0247e80b18eaa05/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67)](https://camo.githubusercontent.com/a87daa8201015ff54a213d9ea95c1e49e7eec447938c441dd0247e80b18eaa05/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67)



**2.2 优先级调度**

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

**2.3 多级反馈队列**

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

[![img](https://camo.githubusercontent.com/c20fd7a3268ebc4ef0bce390344de2c5358392ecef2413d849c3095e21047980/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67)](https://camo.githubusercontent.com/c20fd7a3268ebc4ef0bce390344de2c5358392ecef2413d849c3095e21047980/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67)



#### 3. 实时系统

实时系统**要求一个请求在一个确定时间内得到响应**。

分为**硬实时**和**软实时**，前者必须**满足绝对的截止时间**，后者可以**容忍一定的超时**。

### 进程同步🌟

#### 基本概述

两种制约形式：

- 间接制约
- 直接制约

临界资源

临界区：每个进程中访问临界资源的那段代码

**同步机制遵循的原则：**

1. 空闲让进
2. 忙则等待（互斥等待）
3. 有限等待（等待一定时间，避免死等）
4. 让权等待（当进程不能进入自己的临界区时，应该释放处理机，以免陷入忙等状态）

### 进程通信

**进程同步与进程通信很容易混淆，它们的区别在于：**

- **进程同步：控制多个进程按一定顺序执行；**
- **进程通信：进程间传输信息。**

**进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。**

#### 1、管道( pipe )
管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

#### 2、有名管道（FIFO）
有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

#### 3、信号
用于通知 接收进程 某个事件已经发生，主要作为**进程间以及同一进程不同线程之间的同步手段**。

#### 4、信号量
信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种**锁机制**，防止某进程正在访问共享资源时，其他进程也访问该资源。Semaphore（信号量）是用来**控制同时访问特定资源的线程数量**。线程可以通过acquire()方法来获取信号量的许可，当信号量中没有可用的许可的时候，线程阻塞，直到有可用的许可为止。线程可以通过release()方法释放它持有的信号量的许可。

#### 5、消息队列
消息队列是消息的链表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。**消息队列优势：克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。**

#### 6、共享内存
两个或多个进程共享一个给定的存储区。      特点：共享内存是最快的一种 IPC(进程间通信)，因为进程是直接对内存进行存取，消息队列和管道需要进行4次：1，由用户空间的buf中将数据拷贝到内核buf中。2，内核buf将数据拷贝到内存中。3，内存到内核。4，内核到用户空间的buf，而共享内存只需要2次；
其次多个进程可以同时操作，所以需要进行同步。因此信号量/互斥锁+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。

#### 7、套接字socket
套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信

## 线程

> **独立调度的基本单位**
>
> 一个进程里有多个线程，共享进程资源。

### 线程状态

> 和进程差不多

### 线程同步🌟

- 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。
- 信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
- 事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。

### 线程通信

**主要方式：共享内存/ 消息传递/ 管道流**

[**详细代码和解释**](https://zhuanlan.zhihu.com/p/138689342)

#### 1. 共享内存

线程之间共享程序的公共状态，线程之间通过读-写内存中的公共状态来隐式通信。

> volatile共享内存

#### 2. 消息传递

线程之间没有公共的状态，线程之间必须通过明确的发送信息来显示的进行通信。

> Wait/notify
>
> Lock/ Condition await() or signal()
>
> 生产者消费者模式

#### 3. 管道流

管道输入/输出流的形式，通信前需要先进行绑定connect(reader)

```java
PipedWriter writer  = new PipedWriter();
PipedReader reader = new PipedReader();
//使用connect方法将输入流和输出流连接起来
writer.connect(reader);
```

## 区别

1. 资源：进程拥有资源
2. 调度：同一个进程中，线程的切换不会引起进程切换；不同进程中的线程切换会引起进程切换
3. 系统开销：进程切换=>涉及CPU环境的保存+新调度进程CPU环境的设置；线程切换=>保存和设置**少量寄存器内容**即可。
4. 通信方面：进程通信=>需要借助IPC；线程通信 =>可以直接读写同一个进程中的数据；

# 3. 处理机（CPU）调度与死锁

## 处理机调度层次

高级调度（作业调度）、中级调度、低级调度（进程调度）

## 调度算法的目标

**公共目标：资源利用率/ 公平性/ 平衡性/ 策略强制执行**

### 批处理系统目标

**平均周转时间短/ 系统吞吐量大/ 处理机利用率高**

![image-20220204102413031](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fos.assets/image-20220204102413031.png)

### 分时系统目标

**反应时间快/ 均衡性**

### 实时系统目标

**截止时间保证/ 可预测性**

## 调度队列模型

1. 仅有进程调度的调度队列模型
2. 具有高级和低级调度的调度模型
3. 同时具有三级调度的调度模型

## 调度队列准则

- 面向用户
  - 周转时间
  - 响应时间
  - 截止时间保证
  - 优先权准则
- 面向系统
  - 系统吞吐量
  - 处理机利用率
  - 各类资源合理分配

## 调度算法

### 作业调度和进程调度的区别

一个作业能否占用处理器，什么时间能够占用处理器，必须由**进程调度**来决定。所以，作业调度选中了**一个作业且把它装入内存时**，就应**为该作业创建一个进程**，若有多个作业被装入内存，则内存中同时存在多个进程，这些进程的初始状态为就绪状态，然后，**由进程调度来选择当前可占用处理器的进程**，进程运行中由于某种原因状态发生变化，当它让出处理器时，进程调度就再选另一个作业的进程运行。

![image-20220204111414493](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fos.assets/image-20220204111414493.png)

# 4. 存储器管理

## 存储器概述

### 层次结构

寄存器

高速缓存

主存储器

磁盘缓存

规定磁盘

可移动存储介质

![image-20220204112646191](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fos.assets/image-20220204112646191.png)

### 管理的功能

- **内存分配和回收(malloc函数：申请内存；free函数：释放内存）**
- 内存保护
- **地址映射：将逻辑地址转换成相应的物理地址**
- **内存扩充**

### 为什么需要虚拟地址？

因为没有虚拟地址，程序就直接访问和操作物理内存。那么**造成的问题**呢？

1. 用户程序可以访问任意内存，这样就容易破坏到操作系统，导致系统崩溃。
2. 当运行多个程序的时候，程序B可能会把程序A的内存地址覆盖，导致程序A崩溃。

**总的来说，直接暴露物理地址会对操作系统和同时运行多个程序造成困难和危害。**

**使用了虚拟地址：**

- 程序可以使用一系列相邻的虚拟地址来访问大于可用物理内存不相邻的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页保存到磁盘文件。数据和代码页会根据需要在物理内存与磁盘之间移动。
- 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。

![image-20220204120537857](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fos.assets/image-20220204120537857-4086459.png)

## 内存管理机制🌟

> 简单分为**连续分配管理方式**和**非连续分配管理方式**这两种。
>
> 连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 **块式管理** 。
>
> 非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如**页式管理** 和 **段式管理**。

### 块式管理

**将内存划分为几个固定大小的块，每个块中只包含一个进程**。如果所需内存空间很小，就容易造成内存碎片。

### 页式管理

> **把内存分为大小相等且固定的一页一页的形式，划分力度更大。**提高内存利用率，**减少外碎片**。**页表对应逻辑地址和物理地址。**

![image-20220205133154054](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fos.assets/image-20220205133154054-4039119.png)

对于一个**内存地址转换**，就三个步骤：

1. 把虚拟地址切分成**页号和偏移量**
2. 根据页号，**从页表里查询对应的物理页号**。
3. **直接拿物理页号，加上偏移量，得到物理内存地址。**



> **分页管理中，最重要的两点：**
>
> 1. **虚拟地址到物理地址的转换要<u>快</u>！**
> 2. **解决虚拟地址空间大，页表也会很<u>大</u>的问题。**

#### 快表(解决：快)

可以理解为一种特殊的高速缓存，是页表的一部分。作用与页表相似，但是提高了访问速率。

没有用页表，需要访问两次主存。用了快表，只要访问一次高速缓存，一次主存，这样可加速并提高指令执行速度。

![image-20220205145843445](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fos.assets/image-20220205145843445-4044324.png)

**使用快表之后的地址转换流程是这样的：**

1. 根据虚拟地址中的页号查快表；
2. 如果该页在快表中，直接从快表中读取相应的物理地址；
3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；
4. 当快表填满后，又要登记新页时，就按照一定的**淘汰策略**淘汰掉快表中的一个页。

#### 多级页表(解决：大)

> 通过二级分页的方式，把本来巨大的页表分成两层。避免把所有的页表一直放在内存中。**时间换空间**

![image-20220205141154624](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fos.assets/image-20220205141154624-4041517.png)

### 段式管理

把内存分为一段一段的，**段是有实际意义的。**每个段都定义了一组逻辑信息，主程序段MAIN/ 子程序段X/ 数据段D及栈段S等。段表对应逻辑地址和物理地址。



### 段页式管理

**分页提高内存利用率&分段满足用户需求。**



### 分页机制和分段机制的共同点和区别

**共同点**

- 分页机制和分段机制都是**为了提高内存利用率，较少内存碎片**。
- 页和段都是**离散存储**的，所以两者都是离散分配内存的方式。但是，**每个页和段中的内存是连续的**。

**区别**

- **大小是否可变：页的大小是固定的**，由操作系统决定；而**段的大小不固定**，取决于我们当前运行的程序。
- **出现原因：**分页仅仅是为了**满足操作系统内存管理的需求**，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够**更好满足用户的需要。**
- **地址空间维度：**分页是一维地址空间（给一个偏移量即可，i.e. 虚拟地址4000，页面大小3000，4000-3000=1000；在第二个页面的1000位置），分段是二维的（需要知道段号和偏移量）。



## 虚拟存储器

**是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外在容量所决定，其运行速度接近于内存速度，每位的成本接近于外存。**

虚拟存储器理论基础：时间局部性原理和空间局部性原理。

虚拟存储器的实现方法：其实现，都是建立在离散分配的存储管理方式的基础上。一般有分两种：请求分页系统、请求分段系统。

**虚拟内存**

> 虚拟内存的目的是为了让**物理内存扩充成更大的逻辑内存**，从而让程序获得更多的可用内存。**一个程序不需要全部调入内存就可以运行**，这使得有限的内存运行大程序成为可能。
>
> **虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间）**
>
> **目的：解决大作业内存不足**

![image-20220206104236100](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fos.assets/image-20220206104236100-4115357.png)

**实现**

**虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。** **<u>虚拟内存的实现有以下三种方式</u>**：

### **请求分页存储管理** 

**请求分页和页式存储管理区别**

**区别点：**

是否将作业的全部地址空间同时装入主存！请求分页存储管理提供虚存。

**共同点：**

1. 一定容量的外存和内存
2. 缺页中断
3. 虚拟地址空间

> 建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。

>https://blog.csdn.net/qq_28602957/article/details/53744956

#### 请求分页的页表机制

![image-20220207102037603](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fos.assets/image-20220207102037603-4200438.png)

- **状态位 P：**指示该页**是否已调入内存**。 供程序访问时参考
- **访问字段 A：**记录本页在一段时间内**被访问的次数或最近未被访问的时间**。 供选择页面换出时参考
- **修改位 M：**表示该页在**调入内存后是否被修改过**。若修改过，则置换该页时需重写该页至外存。 供置换页面时参考
- **外存地址：**指出该页在**外存上的地址**。供调入该页时参考

#### 缺页中断机构

在请求分页系统中，**当访问的页不在内存，便产生一个缺页中断**。

缺页中断与一般中断的区别：

- **缺页中断是在指令执行期间产生和处理中断信号**（要访问的指令或数据不在内存） 。
- 一条指令在执行期间，**可能产生多次缺页中断**。

#### 地址变换机构🌟

![image-20220207102607568](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fos.assets/image-20220207102607568-4200768.png)

#### 请求分页系统的内存分配

- 最小物理块数的确定

  - 采用**直接寻址方式**，所需的最少物理块数为 2。一块是用于存放指令，另一块用于存放数据。
  - **间接寻址**时，至少要求有三个物理块。 （间接寻址中一些物理块放的是其它物理块的块号）

- 内存分配策略

  - 固定分配局部置换

    >**为每个进程分配固定数目 n 的物理块，在整个运行中都不改变。如出现缺页则从该进程的页面中置换一页。**
    >
    >每个进程分配多少个物理块难以确定.
    >
    >若太少，会频繁地出现缺页中断，降低了系统的吞吐量。
    >
    >若太多，内存中驻留的进程数目减少，可能造成 CPU空闲或其它资源空闲的情况。

  - 可变分配全局置换

    > 为每个进程分配一定数目的物理块，但 **OS 自留一空闲块队列**，若发现缺页，则从空闲块队列中分配一空闲块与该进程，并调入缺页于其中。**当空闲块队列用完时，OS 才从内存中任选择一页置换。**

  - 可变分配局部置换

    > 为每个进程分配一定数目的物理块，**若发现缺页，则从该进程的页面中置换一页**，不会影响其它进程的运行。**根据进程缺页率高低，则可增加或减少分配给该进程的物理块。**

- 物理块分配算法

  - 平均分配算法

    > 平均分配给各个进程。未考虑进程大小，小进程浪费物理块，大进程严重缺页。

  - 按比例分配算法

    > **每个进程被分到的物理块数bi = 系统可用物理块总数m ✖️ 每个进程的页面数Si/ 【SUM(i=1 to n个进程)Si】总页面数**

  - 优先考虑权分配算法

    > 将系统提供的物理块一部分根据进程大小先按比例分配给各个进程，另一部分再根据各进程的优先权分配物理块数

#### 页面调入策略

- 何时调入

  - **预调页**：将预计在不久之后便会被访问的页面预先调入内存。

    > 进程的页一般存放在外存的一个连续区域中。一次调入若干个相邻的页会比一次调入一页更高效。
    >
    > 但如果调入的一批页面中的大多数都未被访问，则浪费了内存。

  - **请求调页策略**：当进程在运行中发生缺页时，就立即提出请求，由系统将缺页调入内存。但这种策略每次仅调入一页，须花费较大的系统开销，增加了启动磁盘 I/O 的频率。

  **总结：预调页浪费内存（空间），请求调页降低效率（时间）**

- 何处调页

  - **对换区**：如果系统**有足够的对换区空间**，运行前可将与进程相关的文件从文件区复制至对换区，以后缺页时全部从对换区调页。
  - **文件区**：如果系统**没有足够的对换区空间**，凡是**不会被修改的文件，直接从文件区调页**，不必回写（换出） 。对**可能会修改的文件第一次直接从文件区调页，换出时换至对换区，以后从对换区调页。**
  - **UNIX 方式**：凡**未运行过**的页面均**从文件区**调页，**运行过**的页面和换出的页面均**从对换区**调页。

  **调页选择优先级：对换区(空间足够)>文件区(是否会被修改？文件区：对换区)；**

  **UNIX：新页面从文件区，运行过的从对换区**

- 调入过程	![image-20220207112459206](%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9Fos.assets/image-20220207112459206-4204300.png)

- 缺页率

#### 页面置换算法🌟

- **最佳置换算法（Optimal）**：即选择那些永不使用的，或者是在最长时间内不再被访问的页面置换出去。（它是一种理想化的算法，性能最好，但在实际上难于实现）。  
- **先进先出置换算法（FIFO）**：该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。  
- **最近最久未使用置换算法LRU（Least Recently Used）**：该算法是选择最近最久未使用的页面予以淘汰，系统在每个页面设置一个访问字段，用以记录这个页面自上次被访问以来所经历的时间T，当要淘汰一个页面时，选择T最大的页面。  
- **Clock置换算法（第二次机会算法）**：该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个**循环队列**。当某页被访问时，其访问位置“1”。在选择一页淘汰时，就检查其访问位，如果是“0”，就选择该页换出；若为“1”，则重新置为“0”，暂不换出该页，在循环队列中检查下一个页面，直到访问位为“0”的页面为止。由于该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将未使用过的页面换出去，所以把该算法称为最近未用算法。  **如果所有位都为 1，第二次机会置换退化为 FIFO 替换。**
- **增强型第二次机会算法**：(0,0)<(0,1)<(1,0)<(1,1)，**目的：减少I/O数量**
  - 通过将引用位和修改位作为有序对，可以改进二次机会算法。有了这两个位，就有下面四种可能的类型：
    - (0，0)：最近没有使用且没有修改的页面，最佳的页面置换。
    - (0，1)：最近没有使用但修改过的页面，不太好的置换，因为在置换之前需要将页面写出。
    - (1，0)：最近使用过但没有修改的页面，可能很快再次使用。
    - (1，1)：最近使用过且修改过，可能很快再次使用，并且在置换之前需要将页面写出到磁盘。

- **最少使用置换算法LFU**：该算法选择最近时期使用最少的页面作为淘汰页。

### **请求分段存储管理** 

建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。

### **请求段页式存储管理**

### 局部性原理

> 局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。

局部性原理表现在以下两个方面：

1. **时间局部性** ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问。产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。
2. **空间局部性** ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。

时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。

空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。

虚拟内存技术实际上就是建立了 “内存一外存”的两级存储器的结构，利用局部性原理实现髙速缓存。

### CPU寻址

**MMU：Memory Management Unit（CPU中的），完成虚拟地址转换为物理地址的硬件。**

使用MMU将虚拟地址转换成物理内存地址的过程。



- 

### 抖动

所谓抖动是指，在具有***虚拟存储器***的计算机系统中，由于**频繁的页面置换活动，使得访问外存储器次数过多，从而引起的系统效率大大降低的一种现象。****
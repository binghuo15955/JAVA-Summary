## JVM垃圾收集器

- [JVM垃圾收集器](#jvm垃圾收集器)
- [- G1收集器](#--g1收集器)
  - [相关概念了解](#相关概念了解)
  - [概览](#概览)
  - [CMS收集器](#cms收集器)
    - [缺点](#缺点)
    - [参数](#参数)
    - [步骤](#步骤)
  - [G1收集器](#g1收集器)
---
参考资料

**[CSDN-Java——七种垃圾收集器+JDK11最新ZGC](https://blog.csdn.net/CrankZ/article/details/86009279)**

**[CSDN-JDK8垃圾收集器特性总结](https://blog.csdn.net/weixin_43508555/article/details/105350303)**

**[什么是GC Roots直接引用的对象](https://blog.csdn.net/shuiCSDN/article/details/104145483)**

---

### 相关概念了解

- 堆内存

- 垃圾回收

- 可达性算法

- GC ROOTS：**类的静态变量**，或者**方法的局部变量**

- 并行和并发

- Minor GC和Full GC

- 吞吐量

  吞吐量就是**CPU ** **用于运行用户代码的时间**与**CPU** **总消耗时间** 的比值，即

  **吞吐量 =** **运行用户代码时间 / ** **（运行用户代码时间 +  垃圾收集时间）。**

  假设虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

- 强引用>软引用>弱引用>虚引用

- Stop-The-World 

  又称GC停顿：会把用户正常的线程全部停止来执行垃圾回收线程

  为什么？因为要保证可达性分析的时候确保对象引用关系不变化，需要和快照保持一致性

- 查看垃圾收集器`java -XX: +PrintCommandLineFlags –version`

- 7种垃圾收集器

- 3种垃圾回收算法

---

### 概览

![未命名文件](JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.assets/%E6%9C%AA%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6-8052995.png)

- Serial进化Serial Old：都是单线程、STW、简单高效
- Serial进化parNew：Serial多线程版本
- Parallel Scavenge进化Parallel Old：都是多线程，吞吐量大

### CMS收集器

- (Concurrent Mark-Sweep) 并发收集器，第一个能让垃圾收集线程和用户线程（基本）同时工作；
- 采用**标记-清除算法**
- **低停顿场景：老年代不频繁GC的场景下适用**

#### 缺点

- **CPU资源敏感：**虽然在并发执行的阶段，不会导致STW，让用户线程停顿。但是会占用更多的CPU资源**导致其他应用程序变慢，总吞吐量下降。**

- **浮动垃圾：**因为并发收集的时候，用户线程产生的新垃圾只能等到下一次的垃圾回收清理；

   **-XX:CMSInitiatingOccupancyFraction**：设置CMS预留内存空间；

     JDK1.5默认值为68%；

     JDK1.6变为大约92%；

- **“Concurrent Mode Failure”失败：**如果CMS运行期间预留的内存无法满足程序需求，会出现并发模式失败；这个时候虚拟机会**临时启用Serial Old收集器**来进行老年代的垃圾收集，从而导致一个新的Full GC。**停顿时间变长**

- **大量内存碎片：**这个是**标记-清除算法**的问题。导致**提前触发Full GC**。

#### 参数

**-XX:+UseConcMarkSweepGC**：使用CMS收集器
**-XX:+ UseCMSCompactAtFullCollection**：**Full GC后，进行一次碎片整理**；整理过程是独占的，会引起停顿时间变长
**-XX:+CMSFullGCsBeforeCompaction**：设置进行几次Full GC后，进行一次碎片整理，默认为0
**-XX:ParallelCMSThreads**：设定CMS的线程数量（一般情况约等于可用CPU数量） 

#### 步骤

![img](JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.assets/20190107162304806.png)

**1、初始标记（initial mark）**

- 单线程执行
- 需要“Stop The World”，但**仅仅把GC Roots的直接关联可达的对象**给标记一下，由于直接关联对象比较小，所以这里的速度非常快

**2、并发标记（concurrent mark）**

- 对于初始标记过程所标记的初始标记对象，进行并发追踪标记，
- 此时其他线程仍可以继续工作。
- 此处时间较长，但不停顿。
- 并不能保证可以标记出所有的存活对象；

**3、重新标记（remark）**

- 在并发标记的过程中，由于可能还会产生新的垃圾，所以此时需要重新标记新产生的垃圾。
- 此处执行并行标记，与用户线程不并发，所以依然是“Stop The World”，
- 且停顿时间比初始标记稍长，但远比并发标记短。

**4、并发清除（concurrent sweep）**

- 并发清除之前所标记的垃圾。
- 其他用户线程仍可以工作，不需要停顿。



### G1收集器



![image-20220324000610454](JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.assets/image-20220324000610454.png)

**1、Region概念**
横跨整个堆内存，布局将整个Java堆划分为多个大小相等的独立区域（Region）。
**2、可并行，可并发**
能充分利用多CPU、多核环境下的硬件优势；
并行：使用多个CPU来缩短Stop-The-World停顿的时间，
并发：也可以并发让垃圾收集与用户程序同时进行
**3、分代收集，收集范围包括新生代和老年代** 
能独立管理整个GC堆（新生代和老年代），而不需要与其他收集器搭配；能够采用不同方式处理不同时期的对象；
**4、空间整合，不产生碎片**
从整体看，是基于标记-整理算法；
从局部（两个Region间）看，是基于复制算法；
这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。
**5、可预测的停顿：低停顿的同时实现高吞吐量**
G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。
G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region，保证了在有限的时间内尽可能提高效率。（这也就是Garbage-First名称的来由）。
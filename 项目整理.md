# 推特用户圣诞节的情绪分析

## RDDs

- 弹性分布式数据集

- 是一个可以并行操作的容错集合

### **创建RDDs的方式**

1. 将现有的集合并行化

> *parallelizing* an existing collection in your driver program

```java
List<Integer> data = Arrays.asList(1, 2, 3, 4, 5);
JavaRDD<Integer> distData = sc.parallelize(data);
```



2. 从外部存储系统导入数据

例如共享的文件系统，HDFS，HBase或其他 Hadoop 数据格式的数据源



# 基于区块链的校园二手交易平台



## 简历描述

**项目时间：2020.02-2020.04	      项目名称：基于区块链和推荐系统的校园二手交易平台**	

**项目使用技术：Springboot、SSM、Tomcat、Redis、Layui、MySQL、WebSocket**

**项目开发平台：IDEA**

**实现模块：==商品管理模块/ 订单模块/ 发布订阅模块/ 聊天模块/ 用户管理/ 用户行为管理==**

**项目过程：编写需求文档，构建项目表结构，使用MVC思想搭建交易平台的web界面、业务逻辑、ORM框架。待整体框架结束后，开始整合订单与区块链，并使用多个节点进行了联调测试。最后加入推荐系统模块，模拟收集了用户的收藏、点赞、对商品评分来进行相似性推荐，而后自动生成了大概1000个随机用户以及随机喜好分布，然后使用Pearson correlation进行协同过滤。**



## 商品管理模块

[商品管理模块🔗](https://blog.csdn.net/ws6afa88/article/details/108989549)


### 数据库字段

| 字段名 | 解释     | 描述                    |
| ------ | -------- | ----------------------- |
| STATUS | 商品状态 | 0: 代表下架；1:代表正常 |
| RANK   | 商品排名 |                         |
|        |          |                         |



### UV管理
> **参考链接🔗** 
>
> [SpringTask定时器](https://cloud.tencent.com/developer/article/1582434)
>
> [获取当前时间](https://cloud.tencent.com/developer/article/1532036#:~:text=java%20%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%202019-11-04%20%E9%98%85%E8%AF%BB%2013.6K%200%201.%E9%80%9A%E8%BF%87Util%E5%8C%85%E4%B8%AD%E7%9A%84Date%E8%8E%B7%E5%8F%96%20Date,SimpleDateFormat%20%28%22yyyy-MM-dd%20%3Ahh%3Amm%3Ass%22%29%3B%20System.out.println%20%28dateFormat.format%20%28date%29%29%3B%202.%E9%80%9A%E8%BF%87Util%E5%8C%85%E7%9A%84Calendar%20%E8%8E%B7%E5%8F%96)

**==UV:Unique Visitor独立访客，1天内访问某站点的用户数量==**

#### 【v1.0.0】

**==数据库==**

**描述**： 用户在点击具体商品的页面的时候，浏览量+1；

**实现逻辑**：使用JAVA代码，每次当用户点击页面，就往数据库里将对应商品的浏览量+1；

**存在问题/需求**：当并发量大的时候（有很多的用户在访问各种各样的商品），全部的请求落在数据库上，会导致数据库崩掉。

#### 【v1.0.1】

**==Redis（Hash数据结构）+数据库==**

**描述**：

1. 解决**【v1.0.0】**的并发问题；

**实现原理：**

1. 加入Redis缓存服务器，使用Hash来存储。

   ```sh
   127.0.0.1:6379> hset product 1 1
   (integer) 1
   127.0.0.1:6379> hincrby product 1 1 # hincrby:指定增量/减量
   (integer) 2
   ```

   用户点击商品后，业务层会在Redis上进行对应商品浏览量的+1；

**存在问题/需求**：

1. 会出现一个用户多次点击商品，浏览量疯狂+1的情况

#### 【v1.0.2】

**==加入Redis（Hyperloglogs）+Springboot的@Scheduled注解==**

**描述：**解决**【v1.0.1】**解决用户在24小时内多次访问，浏览量一直+1的情况；

**难点**：一开始打算使用Redis的Set集合去对每一个商品维护一个浏览用户的集合；但是发现当商品数目和浏览人数多起来后，需要**存储大量的信息**，不合适！

后来发现了**HyperLogLogs数据类型**，用来做基数统计。我要统计的浏览量正好就是集合基数；

**实现原理：**

使用Redis的HyperLoglogs数据类型，用来做基数统计。

1. 一旦用户点击了商品链接，业务层会调用命令`pfadd pid:1 usr:1 `加入一个用户

2. 使用通过命令`pfcount pid:1`来获取当天指定商品的用户访问量

3. 将==**HyperLogLogs当天访问量+Hash保存的这天之前的总访问量=目前的访问量**==；

4. **==使用`@Scheduled`注解实现每天0点进行一次同步到数据库中==**，并更新Hash值，清空HyperLogLogs；

   **@Scheduled:**由于是单线程执行，所以下一次任务是需要等待上一次任务结束才能执行，就会出现延迟执行的情况。
   
   ```java
   package com.beibei;
   
   import org.springframework.boot.SpringApplication;
   import org.springframework.boot.autoconfigure.SpringBootApplication;
   import org.springframework.scheduling.annotation.EnableScheduling;
   
   @EnableScheduling
   @SpringBootApplication
   public class Springboot03TaskApplication {
   
       public static void main(String[] args) {
           SpringApplication.run(Springboot03TaskApplication.class, args);
       }
   
   }
   ```
   
   
   
   ```java
   package com.beibei;
   
   import org.springframework.scheduling.annotation.Scheduled;
   import org.springframework.stereotype.Component;
   
   import java.text.SimpleDateFormat;
   import java.util.Calendar;
   
   @Component
   public class MyScheduleTask {
   
       @Scheduled(cron = "0 * * * * *")
       public void task1() {
           Calendar calendar = Calendar.getInstance();
           SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
           System.out.println("【" + simpleDateFormat.format(calendar.getTime()) + "】" + Thread.currentThread().getName() + "==> This is a task1()");
       }
   }
   ```
   
   ![image-20220227002711956](%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%A0%A1%E5%9B%AD%E4%BA%8C%E6%89%8B%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0.assets/image-20220227002711956.png)

### PV管理

#### 【v1.0.0】

**==Redis(Hash)+MySQL数据库+定时器==**

**描述**：新增了PV（页面浏览量）的统计

**实现原理：**直接使用Redis的Hash来进行统计，也是每天0点进行同步到数据库。



### 点赞/ 收藏/ UV排行榜管理

> **参考🔗**
>
> **[使用Redis实现排行榜**](https://www.cnblogs.com/thisiswhy/p/14470861.html)

**==根据商品的点赞量/ 收藏量/ UV量 来做排行榜==**



#### 【v1.0.0】

使用**==数据库==**进行排序

**原理：**

1. 修改的时候，直接到数据库里修改即可；
2. 查询的时候，使用窗口函数rank()

**问题**：当修改的并发量很高的的时候，也顶不住。



#### 【v1.0.1】

堆来维护 TOP 100.

用户先将自己的点赞量+1后，判断是否比堆顶元素大，大则poll出堆顶元素，把自己加入进去。



#### 【v1.0.2】

**==采用Redis的zset==**



利用**==Java的Array\<Product>+Map<Integer,Product>==**来实现（完全的内存排序）。LinkedList里存储的是**一个商品对象**，比较**对象里的收藏量**；

**描述：**为了解决数据库压力过大的问题；通过4项指标分别**全量排序**，非实时，定时周期任务1小时一次

**原理**：

1. Map会去读取数据库里的商品浏览量、排名数据
2. 当浏览量有变动后，就会通过**Map去找到对应的商品**，然后修改对应收藏量+1；==（会出现并发问题：当多个用户同时收藏了商品，就会同时对收藏量+1，最终只加了1）（**<u>FIX</u>**：使用了JUC下的AtomicInteger类中的getAndIncrement()方法来解决==
3. 通过排序Array 消耗O($nlogn$)==（在排序过程会有并发问题：一开始使用了Synchronized,后来用lock，最后用CAS）==，然后获取到当前排名。
4. 返回给前端
5. 每10分钟进行持久化同步到数据库

**问题**：

1、维护的数量巨大的时候，要消耗巨大的CPU资源来排序以及消耗巨大内存来存储；

2、加锁效率非常低下，请求量大的时候，常要等待很久或者请求失败

3、每10分钟同步，意味着可能会丢失10分钟的数据。



#### 【v1.0.2】

**==数据库+Map+LinkedList==**

**描述**：

1. 提高排序效率【解决1.0.1的问题】
2. 场景：用户会经常查看自己商品的排名

**原理**：

1. **当有UV变动的时候**，在对应商品上加对应数字，加完之后，开始依次比较前一个对象，UV量只要>它就往前走，并交换排名；Util不大于前一个的浏览量，则停止；
2. 使用**==Map==**维护一个用户ID==>商品对象列表的映射，即可获取到用户发布的商品的实时排名；

<img src="%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%A0%A1%E5%9B%AD%E4%BA%8C%E6%89%8B%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0.assets/image-20220227115444161.png" alt="image-20220227115444161" style="zoom:50%;" /> 

**问题：**

1. 10分钟的信息可靠性无法保障
2. 一次请求就需要一个线程来处理，高并发下，无法保证服务可用性。



#### 【v1.0.3】

**==Redis+定期同步数据库==**

**描述**

1. 解决了10分钟的信息会丢失的问题；通过rdb和aof的方式
2. 每天同步一次数据库；
3. 解决【1.0.2】的一次请求就要一个线程来排序的问题；因为Redis是单线程的。
4. 解决高并发下的线程安全问题；

通过ZSet来实现。

```sh
# 刚启动，同步数据库信息
zadd viewRank 20 "user:1 pid：3"
zadd viewRank 31 "user:1 pid：55"
zadd viewRank 30 "user:2 pid：4"

zincrby viewRank 1 "user:2" # 浏览量变动+1

zrevrank  viewRank "user:2" # 获取userid为2的排名

zrange/zrevrange key start end [withscores] # 返回指定排名范围内的 member  TOP排行榜
```



### 3. 库存管理

秒杀活动

### 4. 发布订阅管理

> 参考资料：
>
> [redis_pub_sub.github](https://github.com/kuanxue/redis_pub_sub/blob/master/src/main/java/com/kuanxue/HelloWorld.java)

使用了Redis的pub/sub模式来实现

#### 【v1.0.0】

**==数据库存储收藏记录==**

**描述**：当一个商户发布了新商品的时候，会通知所有收藏它的用户。 

用户点击收藏商家的时候，就会作为商家的一个订阅者，同时将信息保存到数据库中；退订，就删除数据库信息即可；

**实现逻辑**：

1. 当有一个用户订阅了一个商家，此时就在数据库里创建一条记录。  

   **发布订阅表**：发布订阅id / 发布者id / 订阅者id / 状态

   > 订阅信息表：订阅信息id / 发布订阅id / 相关信息

2. 当商家发布一个新商品的时候，会改变订阅表的状态为1；

3. 前端页面会周期性地去获取订阅表的情况，有则更新；

4. 完成推送任务！

**存在问题/需求**：

1. 需要定期请求发布订阅表的是否变化，容易造成**数据库压力过大**；
2. 无法完成当发布者发布后，服务器主动推送到对应订阅者位置。**实时性**



#### 【v1.0.1】

**==利用观察者模式Observer+socket建立TCP长连接（BIO模型）==**

**解决的问题**：1. 降低对数据库的访问压力；2. 实时性的保证

**逻辑**：

1. 当用户登录后，会读取一次数据库，并根据信息，建立起观察者和被观察者对象。
2. 当指定商户，此时更新了一些对应商品后，订阅者都会被notifyObersver方法通知到；

![image-20220302122348820](%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%A0%A1%E5%9B%AD%E4%BA%8C%E6%89%8B%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0.assets/image-20220302122348820.png)



### 5. 评论模块

#### 【v1.0.0】

***实现一个商品多人评论***

**评论表结构：**

| 字段名   | 解释       | 描述 |
| -------- | ---------- | ---- |
| CID      | 评论ID     |      |
| PID      | 商品ID     |      |
| FROM_UID | 评论用户ID |      |
| CONTENT  | 内容       |      |

**评论点赞表结构**

| 字段名 | 解释   | 描述 |
| ------ | ------ | ---- |
| CID    | 评论ID |      |
| COUNT  | 点赞数 |      |



#### 【v1.0.1】

***新增嵌套回复评论***

**评论父子表结构：**

| 字段名       | 解释     | 描述 |
| ------------ | -------- | ---- |
| ID           | 主键ID   |      |
| P_COMMENT_ID | 父评论ID |      |
| C_COMMENT_ID | 子评论ID |      |



**回复表结构：**

| 字段名     | 解释             | 描述                                               |
| ---------- | ---------------- | -------------------------------------------------- |
| RID        | 主键ID           |                                                    |
| CID        | 根评论ID         | 外键(评论表主键)指向一条评论                       |
| FROM_UID   | 评论用户ID       | 为了标明是谁给谁回复                               |
| TO_UID     | 评论目标用户ID   | 为了标明是谁给谁回复                               |
| CONTENT    | 内容             |                                                    |
| Reply_ID   | 回复的comment id | 如果type=0，Reply_ID=CID，如果type=1，Reply_ID=RID |
| Reply_TYPE | 回复类型         | 如果是0:表示回复根评论；如果是1:表示回复子评论     |



## 订单模块

### 1.拼团

#### 【v1.0.1】

**技术**：使用**==CyclicBarrier==**来实现多人拼团业务；

**原理**：

1. 当用户想购买某项商品的时候，就可以发起一个在线拼团；
2. 服务器接收到客户端发送过来的拼团请求
3. 查看当前商品是否已经存在拼团单中（通过商品的id来查询）；
4. 存在则加入，不存在则创建；
5. 设置一个过期时间24小时，超过则拼团失败；
6. 达到拼团人数，执行库存数量检查
7. 拼团成功则生成3个订单到数据库存储，结束！

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;
import java.util.concurrent.TimeUnit;

public class CyclicBarrierTest {

    static List<String> list = new ArrayList<>();
    static Map<String, CyclicBarrier> map = new HashMap<>();

    public static void main(String[] args) throws InterruptedException {
        for (int i = 0; i < 6; i++) {
            TimeUnit.SECONDS.sleep(1);
            new CyclicBarrierTest().addBuyTogether(String.valueOf(i), "2", 3);
        }
    }

    private void addBuyTogether(String uid, String pid, int parties) {

        if (list.isEmpty() || !list.contains(pid)) {
            list.add(pid);
            map.put(pid, new CyclicBarrier(parties, () -> {
                System.out.println(parties + "人拼团任务已经完成！订单提交！");
            }));
        }

        CyclicBarrier barrier = map.get(pid);
        new Thread(() -> {
            System.out.println("用户"+Thread.currentThread().getName() + "加入了购买商品" + pid + "的拼团！");
            System.out.println("当前等待人数：" + (barrier.getNumberWaiting()+1) + "/" + parties);
            try {
                barrier.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            } catch (BrokenBarrierException e) {
                e.printStackTrace();
            }
        }, uid).start();

    }
}
```

<img src="%E9%A1%B9%E7%9B%AE%E6%95%B4%E7%90%86.assets/image-20220304170830289.png" alt="image-20220304170830289" style="zoom:45%;" /> 

#### 【v1.0.2】

**上一版本的问题：**必须用户在线等待；

**描述：**如果线上最没有拼单成功，用户下线了。就会进入到离线拼单环节。使用**==Redis的Set集合==**来存储每个商品的拼团人数，一旦到达`scard pid:3`指定人数，就会拼单成功，记录到`数据库的订单表中`并`srem pid:3 hanhan `清空成功用户，同时通知商家。用户再次登录之后，接收到通知。





### 2.区块链存储订单

**==区块链+WebSocket==**

**难点：**实现区块链和P2P通信

**原理：**

<img src="%E5%9F%BA%E4%BA%8E%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E6%A0%A1%E5%9B%AD%E4%BA%8C%E6%89%8B%E4%BA%A4%E6%98%93%E5%B9%B3%E5%8F%B0.assets/image-20220227112045228.png" alt="image-20220227112045228" style="zoom:50%;" />

## 登录模块







## 聊天模块

### 1. 买卖双方沟通

**==(买家和卖家沟通)==**

#### 【v1.0.0】

**==文本存储聊天记录+WebSocket通信==**

**描述**：实现卖家和买家的实时沟通

**实现逻辑**：

1. 用户在登录之后，会分配就会和服务器建立一个WebSocket连接；同时会向服务器请求聊天记录。
1. 服务器维护一个用户到socket连接的映射；
2. 当买方（其中一个用户）向卖方（另一个用户）发送消息时，买方会先将接收人ID、发送消息发送到Server端
2. Server查找到对应的接受人ID的socket后，将信息输出到接收方socket；并将信息记录到一个文本中持久化；
2. 接收方就能收到对应的信息了。然后回复同理；

**存在问题**：

1. **通信条件苛刻**：发送消息，必须双方均在线才可以。
2. **消耗资源**：用户之间的**通信并非即时性的**，经常是一个人发送消息后，另一个人过了一会回复。此时socket连接已经断开，需要重新连接才能重新通信，就会出现频繁的创建连接、断开连接。
3. **效率极低**：每次**建立连接需要去同步消息记录**，由于是存储在文件中，需要IO，非常耗时间



**需求**：

1. 可以发送离线消息；
2. 不需要双方建立连接；
3. 聊天记录同步优化；



#### 【v1.0.1】

- 文本存储所有聊天记录（周期性写入）
- 数据库(离线消息表)：实现离线消息

- Redis的pub/sub来做通讯（不需要建立连接）

**==离线消息==**

> **参考🔗** 
>
> **[离线消息机制](https://zhuanlan.zhihu.com/p/42982409)**

```sql
CREATE TABLE `offline_message` (
  `id` int(1) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `msg_id` varchar(32) DEFAULT NULL COMMENT '消息标识（发送人随机生成，不唯一）',
  `send_uid` int(1) NOT NULL COMMENT '发送人ID',
  `received_uid` int(1) NOT NULL COMMENT '接收人ID',
  `msg_type` tinyint(1) NOT NULL COMMENT '消息类型',
  `msg_content` varchar(500) NOT NULL COMMENT '消息内容',
  `send_time` int(1) NOT NULL COMMENT '发送时间',
  `received_time` int(1) NOT NULL COMMENT '成功接收时间',
  `is_receive` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否接收，默认0否，1是',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='离线消息表';
```

**描述**：实现离线消息

**实现逻辑**：

1. 用户登录后，会**去检查一次数据库是否有他的离线消息**
2. 如果有，则会返回一个**Map<String,Integer>**,存储**发送方ID->离线消息数量**的映射；
3. 当用户点击具体用户的时候，会**去数据库拉取对应的离线消息详情**；
4. 然后返回给用户即可；

**==无状态通讯==**

**描述**：实现无状态的通讯（用户是已经登录的），解决socket频繁重新连接的资源消耗。

**实现原理**：

1. 所有登录用户都已经连接上Redis；且Server端的Redis维护着
2. 当【用户A：5】要和【用户B：2】通信的时候（点击了用户B头像），**会先发送一个用户B要订阅的channel频道**（[用户A的ID：RecivedMsg] i.e.【5:RecivedMsg】，用来接收自己用户A的消息）**给Server；**
3. Server用户B的ID去



